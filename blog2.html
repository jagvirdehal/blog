<h1>Efficiency: The Journey to Node.js</h1>
<p>
In Grade 11, we learned to create websites using HTML, CSS and Javascript. A markup language, stylesheets and a generic client-side programming language. For my senior year, I decided to spice things up a little and use the more powerful, Node.js. Node.js is a javascript runtime environment that executes Javascript code server-side. This goes against what Javascript is normally taught as, and the adjustment isnâ€™t very easy. For starters traditionally, you would load an HTML page that links to CSS and Javascript files. However with Node, you instead load the Javascript code first, and using a web framework (like Express JS) you tell the program what HTML pages to render. I wanted to use Node so I could expand my understanding of web programming, but my group members had already created much of the functionality in client side Javascript.
</p>
<p>
Thus, I tasked myself with converting our entire project onto the server-side. My first problem sprouted when I decided to use an SQL database for cloud storage purposes, rather than using the local store previously setup. I needed a way to communicate with the SQL server with Node, and pass all of the data received directly to the HTML page. The solution here was to use the MySQL package. Using the MySQL package, I could connect to the SQL server and send/receive queries all within the Javascript file. It sounds like a very simple solution, but the process of converting from SQL to MySQL took a lot longer than I had expected. With that out of the way, the next step was to send that data to the HTML pages. We accomplished this using a templating engine, however we had to make a decision from the many engines to choose from. The most widely-used templating engines include Jade, Handlebars, and Mustache.js. However, we instead decided to go with the lesser-known EJS (Embedded Javascript); a templating engine that uses many standard conventions from Javascript, and was very easy to pick up and use for our project.
</p>
<p>
Moreover, I ran into a strange issue later on as we furthered our development. Using SQL as the localstorage replacement works well for data that is shared by every user, but not so much with session-by-session data such as the currently logged-in user. For this, I had to install a Node localstorage module that would store data into temporary files on the server, where each session had its own files. For now, this is a bodge fix that may cause problems as the company expands, but it was the quickest and easiest fix we could find.
</p>
